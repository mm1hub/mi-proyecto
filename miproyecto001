# miproyecto001.py

import pygame
import random
from abc import ABC, abstractmethod

# ---------------------------------
# 1. CONFIGURACIÓN GLOBAL
# ---------------------------------
WIDTH, HEIGHT = 800, 600
FPS = 30
TURNO_DURACION_MS = 500 # Un turno de IA por segundo

# Colores (para la Vista)
BLANCO = (255, 255, 255)
AZUL = (0, 0, 255)
VERDE = (0, 255, 0)
MARRON = (139, 69, 19)
GRIS = (169, 169, 169)

# ---------------------------------
# 2. CAPA DE LÓGICA (MODELO)
# ---------------------------------

# --- Clase Base Abstracta (logic/animal.py) ---
class Animal(ABC):
    def __init__(self, nombre, energia, tiempo_vida, ancho=10, alto=10):
        self.nombre = nombre
        self.energia = energia
        self.tiempo_vida = tiempo_vida
        self.edad = 0
        self.rect = pygame.Rect(random.randint(0, WIDTH), random.randint(0, HEIGHT), 10, 10) 
        
        # --- CAMBIO FLUIDEZ ---
        # Objetivo de movimiento (hacia dónde quiere ir)
        self.target_x = self.rect.x
        self.target_y = self.rect.y
        # Velocidad de movimiento (píxeles por frame)
        self.velocidad_frame = random.uniform(1.0, 3.0)
        # Ajustes de posición y buffers en float para movimiento fluido
        # Ajustar tamaño desde parámetros y reencajar en pantalla
        self.rect.width = ancho
        self.rect.height = alto
        if self.rect.right > WIDTH:
            self.rect.right = WIDTH
        if self.rect.bottom > HEIGHT:
            self.rect.bottom = HEIGHT
        # Posición en float y objetivos sincronizados
        self.pos_x = float(self.rect.x)
        self.pos_y = float(self.rect.y)
        self.target_x = self.pos_x
        self.target_y = self.pos_y

    @abstractmethod
    def decidir_objetivo(self, listas_de_seres):
        """(IA - 1 vez/seg) Decide a dónde ir, actualiza target_x/y"""
        pass
    
    @abstractmethod
    def comer(self, objetivo):
        """Lógica de qué pasa cuando come"""
        pass
    
    @abstractmethod
    def reproducir(self):
        """Lógica de qué pasa cuando se reproduce"""
        pass

    def update_decision_turno(self, listas_de_seres):
        """(IA - 1 vez/seg) Envejece, gasta energía y toma decisiones"""
        self.energia -= 5
        self.edad += 1
        self.decidir_objetivo(listas_de_seres)

    def update_movimiento_frame(self):
        """(Movimiento - 60 vez/seg) Se mueve físicamente hacia el objetivo"""
        # Moverse hacia el objetivo X
        if self.rect.x < self.target_x:
            self.rect.x += self.velocidad_frame
        elif self.rect.x > self.target_x:
            self.rect.x -= self.velocidad_frame
            
        # Moverse hacia el objetivo Y
        if self.rect.y < self.target_y:
            self.rect.y += self.velocidad_frame
        elif self.rect.y > self.target_y:
            self.rect.y -= self.velocidad_frame

    def ha_muerto(self):
        return self.edad >= self.tiempo_vida or self.energia <= 0

    def update_movimiento_frame(self):
        """(Movimiento - 60 vez/seg) Se mueve físicamente hacia el objetivo con precisión float"""
        # Calcular desplazamientos hacia el objetivo por eje, saturando por velocidad_frame
        if not hasattr(self, 'pos_x'):
            self.pos_x = float(self.rect.x)
        if not hasattr(self, 'pos_y'):
            self.pos_y = float(self.rect.y)
        dx = self.target_x - self.pos_x
        dy = self.target_y - self.pos_y
        if abs(dx) > 0:
            step_x = max(-self.velocidad_frame, min(self.velocidad_frame, dx))
            self.pos_x += step_x
        if abs(dy) > 0:
            step_y = max(-self.velocidad_frame, min(self.velocidad_frame, dy))
            self.pos_y += step_y
        # Limitar a pantalla
        max_x = max(0, WIDTH - self.rect.width)
        max_y = max(0, HEIGHT - self.rect.height)
        self.pos_x = max(0.0, min(self.pos_x, float(max_x)))
        self.pos_y = max(0.0, min(self.pos_y, float(max_y)))
        self.rect.topleft = (int(self.pos_x), int(self.pos_y))

# --- Clase Planta (logic/planta.py) ---
class Planta:
    def __init__(self, nombre, energia):
        self.nombre = nombre
        self.energia = energia
        self.rect = pygame.Rect(random.randint(0, WIDTH-8), random.randint(0, HEIGHT-8), 8, 8)

# --- Clase Herbívoro (logic/herbivoro.py) ---
class Pez(Animal):
    def __init__(self, nombre, energia, tiempo_vida):
        super().__init__(nombre, energia, tiempo_vida, ancho=10, alto=10)
        
        self.velocidad_frame = random.uniform(2.0, 4.0) # Los peces son rápidos

    def comer(self, planta):
        if isinstance(planta, Planta):
            self.energia += planta.energia

    def reproducir(self):
        if self.energia > 100 and self.edad > 5 and random.random() < 0.1:
            self.energia -= 50
            cria = Pez("Pejerrey", 50, 20)
            cria.rect.topleft = self.rect.topleft
            return cria
        return None

    def decidir_objetivo(self, listas_de_seres):
        """IA del Pez: 1. Huir, 2. Comer, 3. Vagar"""
        lista_depredadores = listas_de_seres["truchas"] + listas_de_seres["tiburones"]
        lista_de_plantas = listas_de_seres["plantas"]
        
        rango_vision_depredador = 150 * 150
        rango_vision_planta = 100 * 100

        depredador_cercano = None
        planta_cercana = None
        dist_min_depredador = rango_vision_depredador
        dist_min_planta = rango_vision_planta

        # 1. Buscar depredadores
        for depredador in lista_depredadores:
            distancia = (self.rect.centerx - depredador.rect.centerx)**2 + (self.rect.centery - depredador.rect.centery)**2
            if distancia < dist_min_depredador:
                dist_min_depredador = distancia
                depredador_cercano = depredador

        # 2. ¿Hay peligro? -> Huir (Poner objetivo LEJOS)
        if depredador_cercano:
            if self.rect.centerx < depredador_cercano.rect.centerx: self.target_x = self.rect.x - 70
            elif self.rect.centerx > depredador_cercano.rect.centerx: self.target_x = self.rect.x + 70
            
            if self.rect.centery < depredador_cercano.rect.centery: self.target_y = self.rect.y - 70
            elif self.rect.centery > depredador_cercano.rect.centery: self.target_y = self.rect.y + 70
        
        # 3. ¿Tiene hambre? -> Buscar comida (Poner objetivo EN la planta)
        elif self.energia < 70:
            for planta in lista_de_plantas:
                distancia = (self.rect.centerx - planta.rect.centerx)**2 + (self.rect.centery - planta.rect.centery)**2
                if distancia < dist_min_planta:
                    dist_min_planta = distancia
                    planta_cercana = planta
            
            if planta_cercana: 
                self.target_x = planta_cercana.rect.centerx
                self.target_y = planta_cercana.rect.centery
            else: # Vagar
                if abs(self.rect.x - self.target_x) < 5 and abs(self.rect.y - self.target_y) < 5:
                    self.target_x = self.rect.x + random.randint(-70, 70)
                    self.target_y = self.rect.y + random.randint(-70, 70)
        
        # 4. Vagar (Poner objetivo aleatorio cercano)
        else:
            if abs(self.rect.x - self.target_x) < 5 and abs(self.rect.y - self.target_y) < 5:
                self.target_x = self.rect.x + random.randint(-70, 70)
                self.target_y = self.rect.y + random.randint(-70, 70)

        # Limitar objetivo a la pantalla
        self.target_x = max(0, min(self.target_x, WIDTH - self.rect.width))
        self.target_y = max(0, min(self.target_y, HEIGHT - self.rect.height))

# --- CLASE SIMPLIFICADA (NUEVA) ---
class Carnivoro(Animal):
    """Clase base para Trucha y Tiburon para no repetir código"""
    def __init__(self, nombre, energia, tiempo_vida, presa_key, hambre_threshold, ancho=12, alto=12):
        super().__init__(nombre, energia, tiempo_vida, ancho=ancho, alto=alto)
        self.presa_key = presa_key # Ej: "peces" o "truchas"
        self.hambre_threshold = hambre_threshold # Ej: 80 o 150

    def decidir_objetivo(self, listas_de_seres):
        """IA del Carnívoro: 1. Cazar, 2. Vagar"""
        lista_de_presas = listas_de_seres[self.presa_key]
        presa_cercana = None
        distancia_minima = float('inf')

        # 1. ¿Tiene hambre? -> Buscar presa
        if self.energia < self.hambre_threshold: 
            for presa in lista_de_presas:
                distancia = (self.rect.centerx - presa.rect.centerx)**2 + (self.rect.centery - presa.rect.centery)**2
                if distancia < distancia_minima:
                    distancia_minima = distancia
                    presa_cercana = presa

        # 2. Moverse
        if presa_cercana: # Hacia la presa
            self.target_x = presa_cercana.rect.centerx
            self.target_y = presa_cercana.rect.centery
        else: # Vagar (si ya llegó al objetivo anterior)
            if abs(self.rect.x - self.target_x) < 5 and abs(self.rect.y - self.target_y) < 5:
                self.target_x = self.rect.x + random.randint(-50, 50)
                self.target_y = self.rect.y + random.randint(-50, 50)
        
        # Limitar objetivo a la pantalla
        self.target_x = max(0, min(self.target_x, WIDTH - self.rect.width))
        self.target_y = max(0, min(self.target_y, HEIGHT - self.rect.height))

# --- Clases Carnívoros (logic/carnivoro.py) ---
# --- SIMPLIFICADAS ---
class Trucha(Carnivoro):
    def __init__(self, nombre, energia, tiempo_vida):
        # Llama a Carnivoro, le dice qué cazar ("peces") y cuándo (80)
        super().__init__(nombre, energia, tiempo_vida, presa_key="peces", hambre_threshold=80, ancho=15, alto=15)
        
        self.velocidad_frame = random.uniform(1.5, 3.5)

    def comer(self, pez):
        if isinstance(pez, Pez):
            self.energia += pez.energia // 2

    def reproducir(self):
        if self.energia > 150 and self.edad > 8 and random.random() < 0.05:
            self.energia -= 70
            cria = Trucha("Trucha", 100, 25)
            cria.rect.topleft = self.rect.topleft
            return cria
        return None
    
    # ¡No necesita 'decidir_objetivo'! Lo hereda de Carnivoro.

class Tiburon(Carnivoro):
    def __init__(self, nombre, energia, tiempo_vida):
        # Llama a Carnivoro, le dice qué cazar ("truchas") y cuándo (150)
        super().__init__(nombre, energia, tiempo_vida, presa_key="truchas", hambre_threshold=150, ancho=20, alto=20)
        
        self.velocidad_frame = random.uniform(1.0, 3.0) # Más lento

    def comer(self, trucha):
        if isinstance(trucha, Trucha):
            self.energia += trucha.energia // 2

    def reproducir(self):
        if self.energia > 200 and self.edad > 10 and random.random() < 0.03:
            self.energia -= 100
            cria = Tiburon("Tiburón", 200, 30)
            cria.rect.topleft = self.rect.topleft
            return cria
        return None
    
    # ¡No necesita 'decidir_objetivo'! Lo hereda de Carnivoro.

# --- Clase Ecosistema (logic/ecosistema.py) ---
class Ecosistema:
    def __init__(self):
        self.peces = []
        self.truchas = []
        self.tiburones = []
        self.plantas = []
    
    def añadir_poblacion_inicial(self):
        for _ in range(25): self.plantas.append(Planta("Alga", 20))
        for _ in range(15): self.peces.append(Pez("Pejerrey", 50, 20))
        for _ in range(5): self.truchas.append(Trucha("Trucha", 100, 25))
        for _ in range(2): self.tiburones.append(Tiburon("Tiburón", 200, 30))

    # Alias ASCII para evitar problemas por mojibake en algunas codificaciones
    def anadir_poblacion_inicial(self):
        try:
            metodo = getattr(self, 'a��adir_poblacion_inicial')
        except AttributeError:
            metodo = None
        if metodo:
            return metodo()
        for _ in range(25): self.plantas.append(Planta("Alga", 20))
        for _ in range(15): self.peces.append(Pez("Pejerrey", 50, 20))
        for _ in range(5): self.truchas.append(Trucha("Trucha", 100, 25))
        for _ in range(2): self.tiburones.append(Tiburon("Tiburón", 200, 30))

    def simular_turno_ia(self):
        """(IA - 1 vez/seg) Corre la lógica de decisión, hambre, muerte, etc."""
        peces_muertos = []
        truchas_muertas = []
        tiburones_muertos = []
        plantas_comidas = []
        nuevas_crias_peces = []
        nuevas_crias_truchas = []
        nuevas_crias_tiburones = []

        listas_de_seres = {
            "peces": self.peces,
            "truchas": self.truchas,
            "tiburones": self.tiburones,
            "plantas": self.plantas
        }

        # --- Lógica de Peces ---
        for pez in self.peces:
            pez.update_decision_turno(listas_de_seres) 
            for planta in self.plantas:
                if pez.rect.colliderect(planta.rect) and planta not in plantas_comidas:
                    pez.comer(planta)
                    plantas_comidas.append(planta)
                    break
            cria = pez.reproducir()
            if cria: nuevas_crias_peces.append(cria)
            if pez.ha_muerto(): peces_muertos.append(pez)

        # --- Lógica de Truchas ---
        for trucha in self.truchas:
            trucha.update_decision_turno(listas_de_seres)
            for pez in self.peces:
                if pez not in peces_muertos and trucha.rect.colliderect(pez.rect):
                    trucha.comer(pez)
                    if pez not in peces_muertos: peces_muertos.append(pez)
                    break
            cria = trucha.reproducir()
            if cria: nuevas_crias_truchas.append(cria)
            if trucha.ha_muerto(): truchas_muertas.append(trucha)

        # --- Lógica de Tiburones ---
        for tiburon in self.tiburones:
            tiburon.update_decision_turno(listas_de_seres)
            for trucha in self.truchas:
                if trucha not in truchas_muertas and tiburon.rect.colliderect(trucha.rect):
                    tiburon.comer(trucha)
                    if trucha not in truchas_muertas: truchas_muertas.append(trucha)
                    break
            cria = tiburon.reproducir()
            if cria: nuevas_crias_tiburones.append(cria)
            if tiburon.ha_muerto(): tiburones_muertos.append(tiburon)

        # --- Limpieza ---
        set_peces_muertos = set(peces_muertos)
        set_truchas_muertas = set(truchas_muertas)
        set_tiburones_muertos = set(tiburones_muertos)
        set_plantas_comidas = set(plantas_comidas)

        self.peces = [p for p in self.peces if p not in set_peces_muertos]
        self.truchas = [t for t in self.truchas if t not in set_truchas_muertas]
        self.tiburones = [t for t in self.tiburones if t not in set_tiburones_muertos]
        self.plantas = [p for p in self.plantas if p not in set_plantas_comidas]

        # --- Adición ---
        self.peces.extend(nuevas_crias_peces)
        self.truchas.extend(nuevas_crias_truchas)
        self.tiburones.extend(nuevas_crias_tiburones)
        
        if random.random() < 0.8: 
            self.plantas.append(Planta("Alga", 20))

    def actualizar_movimiento_frame(self):
        """(Movimiento - 60 vez/seg) Llama a la función de mover de todos"""
        for pez in self.peces:
            pez.update_movimiento_frame()
        for trucha in self.truchas:
            trucha.update_movimiento_frame()
        for tiburon in self.tiburones:
            tiburon.update_movimiento_frame()

# ---------------------------------
# 3. CAPA DE VISTA
# ---------------------------------
class Vista:
    def __init__(self, width, height):
        pygame.init()
        self.width = width
        self.height = height
        self.screen = pygame.display.set_mode((width, height))
        pygame.display.set_caption("Simulador de Ecosistema")
        self.assets = self.cargar_assets()
        try:
            self.font = pygame.font.SysFont(None, 30)
        except:
            print("Warning: No se pudo cargar la fuente. La UI no se mostrará.")
            self.font = None

    def cargar_assets(self):
        assets = {}
        # Asume que hay una carpeta 'assets/' al lado de este script
        try:
            assets['pez'] = pygame.transform.scale(pygame.image.load('assets/pez.png').convert_alpha(), (15, 15))
            assets['trucha'] = pygame.transform.scale(pygame.image.load('assets/trucha.png').convert_alpha(), (25, 25))
            assets['tiburon'] = pygame.transform.scale(pygame.image.load('assets/tiburon.png').convert_alpha(), (30, 30))
            assets['alga'] = pygame.transform.scale(pygame.image.load('assets/alga.png').convert_alpha(), (10, 10))
            print("Assets cargados desde 'assets/'.")
        except FileNotFoundError:
            print("Advertencia: No se encontraron imágenes en 'assets/'. Se usarán círculos.")
            assets = {}
        return assets

    def dibujar_ecosistema(self, ecosistema):
        self.screen.fill(BLANCO)

        # Dibujar (las plantas no se mueven, pero los animales sí)
        for planta in ecosistema.plantas:
            if 'alga' in self.assets: self.screen.blit(self.assets['alga'], planta.rect)
            else: pygame.draw.circle(self.screen, VERDE, planta.rect.center, 5)

        for pez in ecosistema.peces:
            if 'pez' in self.assets: self.screen.blit(self.assets['pez'], pez.rect)
            else: pygame.draw.circle(self.screen, AZUL, pez.rect.center, 8)

        for trucha in ecosistema.truchas:
            if 'trucha' in self.assets: self.screen.blit(self.assets['trucha'], trucha.rect)
            else: pygame.draw.circle(self.screen, MARRON, trucha.rect.center, 12)
        
        for tiburon in ecosistema.tiburones:
            if 'tiburon' in self.assets: self.screen.blit(self.assets['tiburon'], tiburon.rect)
            else: pygame.draw.circle(self.screen, GRIS, tiburon.rect.center, 15)
        
        self.dibujar_ui(ecosistema)
        pygame.display.flip()

    def dibujar_ui(self, ecosistema):
        if not self.font: return 
        pygame.draw.rect(self.screen, (240, 240, 240), (0, 0, self.width, 40))
        textos = [
            (f"Algas: {len(ecosistema.plantas)}", VERDE, 10),
            (f"Peces: {len(ecosistema.peces)}", AZUL, 130),
            (f"Truchas: {len(ecosistema.truchas)}", MARRON, 260),
            (f"Tiburones: {len(ecosistema.tiburones)}", GRIS, 420)
        ]
        for (texto, color, x_pos) in textos:
            img = self.font.render(texto, True, color)
            self.screen.blit(img, (x_pos, 10))

    def cerrar(self):
        pygame.quit()

# ---------------------------------
# 4. FUNCIÓN PRINCIPAL (main.py)
# ---------------------------------
def main():
    ecosistema = Ecosistema()
    ecosistema.añadir_poblacion_inicial()

    vista = Vista(WIDTH, HEIGHT)
    
    clock = pygame.time.Clock()
    proximo_turno_ia = pygame.time.get_ticks() + TURNO_DURACION_MS
    
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        # --- Lógica de IA (1 vez/seg) ---
        ahora = pygame.time.get_ticks()
        if ahora >= proximo_turno_ia:
            ecosistema.simular_turno_ia()
            proximo_turno_ia = ahora + TURNO_DURACION_MS

        # --- Lógica de Movimiento (60 veces/seg) ---
        ecosistema.actualizar_movimiento_frame()

        # --- Renderizado (60 veces/seg) ---
        vista.dibujar_ecosistema(ecosistema)
        
        clock.tick(FPS)

    vista.cerrar()

# ---------------------------------
# 5. PUNTO DE ENTRADA
# ---------------------------------
if __name__ == "__main__":
    main()
